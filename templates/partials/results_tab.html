<div class="row justify-content-center mb-4">
	<div class="col-md-10">
		<div class="card shadow-sm">
			<div class="card-header d-flex justify-content-between align-items-center">
				<span>Live Measurements</span>
				<div class="d-flex align-items-center gap-3">
					<button class="btn btn-sm btn-outline-primary" title="Save Chart Screenshot" onclick="downloadImage()">Save Image</button>
					<button class="btn btn-sm btn-outline-success" title="Save Chart Data in CSV Format" onclick="downloadCSV()">Save CSV</button>
				</div>
			</div>
			<div class="card-body">
				<canvas id="liveChart" height="150"></canvas>
			</div>
		</div>
	</div>
</div>

<div class="row justify-content-center mb-3">
  <div class="col-md-10">
    <div class="card card-body" id="trackTogglePanel">
      <h6 class="mb-3">Toggle Gas Components</h6>
      <div id="trackToggles" class="d-flex flex-wrap gap-3"></div>
    </div>

    <div id="liveNotice" class="small text-muted mt-2" role="status" aria-live="polite"></div>
  </div>
</div>

<script>
	let trackVisibility = {};
	let lastStamp = null;          // ← remember last device timestamp we plotted
  	const MAX_POINTS = 100;        // ← keep the same cap you used implicitly

    const ctx = document.getElementById('liveChart').getContext('2d');
    const liveChart = new Chart(ctx, {
		type: 'line', data: { labels: [], datasets: [] },
		options: {
			responsive: true,
			animation: false,
			scales: {
				x: { title: { display: true, text: 'Time' } },
				y: { title: { display: true, text: 'PPM' }, beginAtZero: true }
			},
			plugins: {
				zoom: {
					zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' },
					pan: { enabled: true, mode: 'x' }
				},
				legend: {
					onClick: function (e, legendItem, legend) {
						const index = legendItem.datasetIndex;
						const chart = legend.chart;
						const label = chart.data.datasets[index].label;

						// Toggle visibility
						const meta = chart.getDatasetMeta(index);
						meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;
						chart.update();

						trackVisibility[label] = chart.isDatasetVisible(index);

						// Update matching checkbox
						const checkbox = document.getElementById(`track-toggle-${index}`);
						if (checkbox) {
							checkbox.checked = trackVisibility[label];
						}

						// update server side config file
						safeFetch(API_PATHS?.settings?.update, {
							method: "POST",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({ track_visibility: trackVisibility })
						});
					}
				}
			}
		}
    });

	function renderTrackToggles() {
		const container = document.getElementById("trackToggles");
		container.innerHTML = ""; // clear before render

		liveChart.data.datasets.forEach((ds, i) => {
			const label = ds.label;
			const id = `track-toggle-${i}`;
			const checked = !ds.hidden;

			const div = document.createElement("div");
			div.classList.add("form-check", "form-switch");

			div.innerHTML = `
				<input class="form-check-input" type="checkbox" role="switch" id="${id}" ${checked ? 'checked' : ''}>
				<div style="display: flex; align-items: center; gap: 6px;">
					<span style="width: 12px; height: 12px; background: ${ds.borderColor}; display: inline-block; border-radius: 2px;"></span>
					<label class="form-check-label" for="${id}" style="color: ${ds.borderColor}; margin: 0;">${label}</label>
				</div>
				`;

			div.querySelector("input").addEventListener("change", (e) => {
				const visible = e.target.checked;
				liveChart.data.datasets[i].hidden = !visible;
				trackVisibility[label] = visible;
				liveChart.update();

				// Save preference
				safeFetch(API_PATHS?.settings?.update, {
					method: "POST",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify({ track_visibility: trackVisibility })
				});
			});

			container.appendChild(div);
		});
	}

	let lastSeenTs = null;

	function onLiveUpdate(d) {
		if (!d.live_data || !d.live_data.components) return; // skip non-data updates

		let ts = d.live_data.timestamp ??  Date.now() / 1000;
		if (typeof ts === "string") {
			ts = Date.parse(ts.replace(" ", "T")) / 1000;
		}

		if (ts && ts === lastSeenTs) return;
  		lastSeenTs = ts;

		const label = new Date(ts * 1000).toLocaleTimeString("en-GB", {
			hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false
		});

		const components = Object.entries(d.live_data.components)
			.map(([label, ppm]) => ({ label, ppm }));

		updateChart(label, components);
	}

	function updateChart(label, components) {
		const isDuplicate = (lastStamp !== null && label === lastStamp);
		let addedDataset = false;

		if (!isDuplicate) {
			liveChart.data.labels.push(label);
			if (liveChart.data.labels.length > MAX_POINTS) liveChart.data.labels.shift();
			liveChart.data.datasets.forEach(ds => {
			ds.data.push(null);
			if (ds.data.length > MAX_POINTS) ds.data.shift();
			});
		}
		const idx = liveChart.data.labels.length - 1;

		components.forEach(c => {
			let ds = liveChart.data.datasets.find(d => d.label === c.label);
			if (!ds) {
			ds = {
				label: c.label,
				data: new Array(liveChart.data.labels.length).fill(null),
				hidden: trackVisibility[c.label] === false,
				borderColor: c.color || undefined,
				backgroundColor: c.color || undefined,
				tension: 0.3
			};
			liveChart.data.datasets.push(ds);
			addedDataset = true;
			}
			ds.data[idx] = c.ppm;
		});

		if (addedDataset) renderTrackToggles();
		liveChart.update();
		lastStamp = label;
	}

	function downloadImage() {
		const link = document.createElement('a');
		link.href = liveChart.toBase64Image();
		const now = new Date();
		const timestamp = now.toISOString().replace(/[:T-]/g, '_').split('.')[0]; // e.g., 2025_07_19_14_32_01
		link.download = `gasera_chart_${timestamp}.png`;
		link.click();
    }

	function downloadCSV() {
		if (liveChart.data.datasets.length === 0) return;

		let csv = 'Time,' + liveChart.data.datasets.map(d => d.label).join(',') + '\n';
		for (let i = 0; i < liveChart.data.labels.length; i++) {
			const row = [liveChart.data.labels[i]];
			liveChart.data.datasets.forEach(ds => row.push(ds.data[i] ?? ""));
			csv += row.join(',') + '\n';
		}

		const blob = new Blob(["\uFEFF" + csv], { type: 'text/csv;charset=utf-8' });
		const link = document.createElement('a');
		link.href = URL.createObjectURL(blob);
		const now = new Date();
		const timestamp = now.toISOString().replace(/[:T-]/g, '_').split('.')[0]; // e.g., 2025_07_19_14_32_01
		link.download = `gasera_data_${timestamp}.csv`;
		link.click();
	}
	
	document.addEventListener("DOMContentLoaded", () => {
		window.GaseraHub?.subscribe(onLiveUpdate);
		console.log("[Live Chart] Subscribed to SSE for live updates");
		renderTrackToggles();
	});

</script>