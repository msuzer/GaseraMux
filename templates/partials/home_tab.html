<div class="container-fluid p-3">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <h4 class="mb-0">Measurement Parameters</h4>
  </div>

  <!-- Configuration -->
  <div class="card mb-3 shadow-sm">
    <div class="card-body">
      <form id="configForm" class="row gy-2 gx-3 align-items-center">
        <div class="col-sm-3">
          <label class="form-label mb-0 small">Measurement (sec)</label>
          <input id="cfgMeasure" type="number" class="form-control form-control-sm" value="300" min="1">
        </div>
        <div class="col-sm-3">
          <label class="form-label mb-0 small">Pause (sec)</label>
          <input id="cfgPause" type="number" class="form-control form-control-sm" value="5" min="0">
        </div>
        <div class="col-sm-3">
          <label class="form-label mb-0 small">Repeat Count</label>
          <input id="cfgRepeat" type="number" class="form-control form-control-sm" value="1" min="1">
        </div>
        <div class="col-sm-3 form-check form-switch mt-4 pt-1">
          <input id="cfgBuzzer" class="form-check-input" type="checkbox" checked>
          <label class="form-check-label small">Enable Buzzer</label>
        </div>
      </form>
    </div>
  </div>

  <!-- Start / Abort -->
  <div class="text-center mb-4">
    <button id="btnStart" class="btn btn-success btn-lg px-5 me-2">Start Measurement</button>
    <button id="btnAbort" class="btn btn-danger btn-lg px-5" disabled>Abort</button>
  </div>

  <!-- Channel selection -->
  <div class="card mb-3 shadow-sm">
    <div class="card-header d-flex justify-content-between align-items-center">
      <span>Channel Selection</span>
      <div class="btn-group btn-group-sm">
        <button id="btnAll" class="btn btn-outline-secondary" type="button">Select All</button>
        <button id="btnNone" class="btn btn-outline-secondary" type="button">Deselect All</button>
        <button id="btnInvert" class="btn btn-outline-secondary" type="button">Invert</button>
      </div>
    </div>
    <div class="card-body">
      <div id="channelGrid" class="d-flex flex-wrap gap-2 justify-content-start"></div>
    </div>
  </div>

  <div class="row g-3 text-center justify-content-center align-items-stretch mt-4">
    <!-- Channel -->
    <div class="col-6 col-md-3">
      <div class="card shadow-sm py-3 h-100">
        <div class="card-title fw-semibold text-muted">CHANNEL</div>
        <div class="circle-wrapper">
          <div class="info-circle channel-info" id="channelCircle">
            <span id="channelBadge" class="value">–</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Repeat -->
    <div class="col-6 col-md-3">
      <div class="card shadow-sm py-3 h-100">
        <div class="card-title fw-semibold text-muted">REPEAT</div>
        <div class="circle-wrapper">
          <div class="info-circle repeat-info" id="repeatCircle">
            <span id="repeatInfo" class="value">–</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Run progress -->
    <div class="col-6 col-md-3">
      <div class="card shadow-sm py-3 h-100">
        <div class="card-title fw-semibold text-muted">RUN PROGRESS</div>
        <div class="circle-wrapper">
          <svg viewBox="0 0 36 36" class="circular-chart blue">
            <path class="circle-bg"
                  d="M18 2.0845 a15.9155 15.9155 0 0 1 0 31.831 a15.9155 15.9155 0 0 1 0 -31.831"/>
            <path id="runCircle" class="circle" stroke-dasharray="0,100"
                  d="M18 2.0845 a15.9155 15.9155 0 0 1 0 31.831 a15.9155 15.9155 0 0 1 0 -31.831"/>
            <g class="text-layer">
              <text x="18" y="18" class="percentage" id="runPct">0%</text>
            </g>
          </svg>
        </div>
      </div>
    </div>

    <!-- Overall progress -->
    <div class="col-6 col-md-3">
      <div class="card shadow-sm py-3 h-100">
        <div class="card-title fw-semibold text-muted">OVERALL</div>
        <div class="circle-wrapper">
          <svg viewBox="0 0 36 36" class="circular-chart green">
            <path class="circle-bg"
                  d="M18 2.0845 a15.9155 15.9155 0 0 1 0 31.831 a15.9155 15.9155 0 0 1 0 -31.831"/>
            <path id="overallCircle" class="circle" stroke-dasharray="0,100"
                  d="M18 2.0845 a15.9155 15.9155 0 0 1 0 31.831 a15.9155 15.9155 0 0 1 0 -31.831"/>
            <g class="text-layer">
              <text x="18" y="18" class="percentage" id="overallPct">0%</text>
            </g>
          </svg>
        </div>
      </div>
    </div>

  </div>

</div>

<!-- Abort modal -->
<div class="modal fade" id="abortConfirmModal" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header bg-warning-subtle">
        <h5 class="modal-title">Confirm Abort</h5>
      </div>
      <div class="modal-body">
        <p class="mb-0">Abort current measurement? This will immediately stop Gasera operation.</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button id="confirmAbort" type="button" class="btn btn-danger">Yes, Abort</button>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  const TOTAL_CHANNELS = 31;
  const START_DELAY = 5;
  let countdownTimer = null;
  let countdown = START_DELAY;
  let evtSrc = null;
  let currentPhase = null;

  const btnStart = document.getElementById("btnStart");
  const btnAbort = document.getElementById("btnAbort");
  const runProgress = document.getElementById("runProgress");
  const grid = document.getElementById("channelGrid");
  const channelBadge = document.getElementById("channelBadge");
  const channelCircle = document.getElementById("channelCircle");
  const repeatInfo   = document.getElementById("repeatInfo");
  const repCircle = document.getElementById("repeatCircle");

  function appendLog(msg){
    if (!msg) return;
    const ts = new Date().toLocaleTimeString();
    console.log(`[${ts}] ${msg}`);
  }

  function applyPhase(phase){
    newPhase = phase || "IDLE";

    if (currentPhase === newPhase) return;

    currentPhase = newPhase;

    if (countdownTimer && currentPhase !== "IDLE") {
      clearInterval(countdownTimer); countdownTimer = null; countdown = START_DELAY;
    }

    switch (currentPhase) {
      case "IDLE":
        resetToIdle("System idle");
        break;
      case "MEASURING":
        btnStart.textContent = "Measuring";
        btnStart.disabled = true;
        btnAbort.disabled = false;
        break;
      case "PAUSED":
        btnStart.textContent = "Paused";
        btnStart.disabled = true;
        btnAbort.disabled = false;
        break;
      case "ABORTED":
        resetToIdle("Measurement aborted");
        break;
      default:
        break;
    }
  }

  function resetToIdle(msg){
    if (msg) appendLog(msg);
    btnStart.disabled = false;
    btnStart.textContent = "Start Measurement";
    btnStart.classList.add("btn-success");
    btnStart.classList.remove("btn-warning");
    btnAbort.disabled = true;
  }

  // Channel grid
  for (let i=0; i<TOTAL_CHANNELS; i++){
    const div = document.createElement("div");
    div.className = "form-check form-check-inline";
    div.innerHTML = `<input class="form-check-input chbox" type="checkbox" id="ch${i}" data-idx="${i}" checked>
                     <label class="form-check-label small" for="ch${i}">${i+1}</label>`;
    grid.appendChild(div);
  }
  
  document.getElementById("btnAll").onclick    = ()=> document.querySelectorAll('.chbox').forEach(c=> c.checked = true);
  document.getElementById("btnNone").onclick   = ()=> document.querySelectorAll('.chbox').forEach(c=> c.checked = false);
  document.getElementById("btnInvert").onclick = ()=> document.querySelectorAll('.chbox').forEach(c=> c.checked = !c.checked);

  function collectPrefsData(){
    return {
      measurement_duration: Number(document.getElementById('cfgMeasure').value),
      pause_seconds: Number(document.getElementById('cfgPause').value),
      repeat_count: Number(document.getElementById('cfgRepeat').value),
      include_channels: Array.from(document.querySelectorAll('.chbox')).map(c=> c.checked)
    };
  }

  function loadPreferences(){
    safeFetch(API_PATHS?.settings?.read)
      .then(r=>r.json())
      .then(p=>{
        document.getElementById('cfgMeasure').value  = p.measurement_duration ?? 300;
        document.getElementById('cfgPause').value    = p.pause_seconds ?? 5;
        document.getElementById('cfgRepeat').value   = p.repeat_count ?? 1;
        document.getElementById('cfgBuzzer').checked = p.buzzer ?? true;
        const mask = p.include_channels ?? [];
        document.querySelectorAll('.chbox').forEach((b,i)=>{ if (i<mask.length) b.checked = mask[i]; });
        appendLog('[UI] Preferences loaded');
      })
      .catch(e=> appendLog('[UI] Pref load failed: ' + e));
  }

  window.addEventListener("beforeunload", () => {
    const body = collectPrefsData();
    try { navigator.sendBeacon(API_PATHS?.settings?.update, JSON.stringify(body)); } catch(_) {}
  });

  // Countdown start
  btnStart.addEventListener('click', ()=>{
    if (currentPhase !== "IDLE") { appendLog("Measurement already running"); return; }
    if (countdownTimer){
      clearInterval(countdownTimer); countdownTimer=null; countdown=START_DELAY;
      btnStart.textContent='Start Measurement';
      btnStart.classList.remove('btn-warning'); btnStart.classList.add('btn-success');
      return;
    }
    countdown=START_DELAY;
    btnStart.classList.remove('btn-success'); btnStart.classList.add('btn-warning');
    btnStart.textContent=`Starting in ${countdown}… (Cancel)`;
    countdownTimer=setInterval(()=>{
      if (currentPhase!=="IDLE"){ clearInterval(countdownTimer); countdownTimer=null; countdown=START_DELAY; return; }
      countdown--;
      btnStart.textContent = countdown>0 ? `Starting in ${countdown}… (Cancel)` : 'Starting…';
      if (countdown<=0){ clearInterval(countdownTimer); countdownTimer=null; startMeasurement(); }
    },1000);
  });

  function startMeasurement(){
    const body = collectPrefsData();
    btnStart.textContent = "Starting…";
    btnStart.disabled = true;
    btnAbort.disabled = true;
    safeFetch(API_PATHS?.measurement?.start, {
      method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body)
    })
    .then(r=>r.json())
    .then(j=>{
      appendLog(j.message || 'Start requested');
    })
    .catch(e=>{ appendLog('Start failed: ' + e); resetToIdle(); });
  }

  // Abort with confirmation
  const abortModal = new bootstrap.Modal(document.getElementById('abortConfirmModal'));
  btnAbort.addEventListener('click', ()=> abortModal.show());
  document.getElementById('confirmAbort').addEventListener('click', ()=>{
    abortModal.hide();
    safeFetch(API_PATHS?.measurement?.abort,{method:'POST'})
      .then(r=>r.json())
      .then(j=>{
        appendLog(j.message || 'Abort requested');
        if (!j.ok) {
          appendLog("[WARN] Abort ignored (no active measurement)");
        }
      })
      .catch(e=> appendLog('Abort failed: ' + e));
  });

  function updateChannelInfo(ch, phase){
    if (channelBadge && channelCircle) {
      channelBadge.textContent = ch + 1;  // 1-based index
      channelCircle.dataset.phase = phase;
    }
  }

  function updateRepeatInfo(rep){
    if (repeatInfo && repCircle) {
      const totalRepeats = Number(document.getElementById("cfgRepeat").value) || 1;
      const currentRepeat = rep + 1;
      repeatInfo.textContent = `${currentRepeat}/${totalRepeats}`;

      // Calculate continuous color intensity (lightness)
      const pct = (currentRepeat / totalRepeats);
      const lightness = 95 - (pct * 55);  // 95% -> 40%

      repCircle.style.setProperty("--repeat-lightness", `${lightness}%`);
      repCircle.style.transition = "background-color 0.6s ease, color 0.6s ease";

      // Text contrast adjustment
      if (lightness < 60) {
        repCircle.style.color = "hsl(0, 0%, 98%)"; // white text on dark bg
        repCircle.classList.add("glow");
      } else {
        repCircle.style.color = "hsl(217, 25%, 25%)"; // dark text on light bg
        repCircle.classList.remove("glow");
      }
    }
  }

    function updateCircularProgress(elId, textId, percent) {
    const circle = document.getElementById(elId);
    const text = document.getElementById(textId);
    const pct = Math.max(0, Math.min(100, percent || 0));

    // stroke animation
    circle.setAttribute("stroke-dasharray", `${pct},100`);
    text.textContent = `${pct}%`;

    // assign color range attribute for CSS hue shift
    let colorRange;
    if (pct <= 25) colorRange = "0-25";
    else if (pct <= 50) colorRange = "26-50";
    else if (pct <= 75) colorRange = "51-75";
    else colorRange = "76-100";

    circle.dataset.pct = colorRange;
  }

  function updateFooterStatus(isOnline, timestamp) {
    const footer = document.querySelector(".status-footer");
    const icon = document.getElementById("connIcon");
    const text = document.getElementById("connStatus");
    const time = document.getElementById("lastUpdate");

    // Connection state
    if (isOnline) {
      footer.classList.add("online");
      footer.classList.remove("offline");
      icon.className = "bi bi-wifi";
      text.textContent = "Gasera Online";
    } else {
      footer.classList.add("offline");
      footer.classList.remove("online");
      icon.className = "bi bi-wifi-off";
      text.textContent = "Gasera Offline";
    }

    // Timestamp
    const ts = timestamp ? new Date(timestamp).toLocaleTimeString("en-GB", {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    }) : "–";

    time.textContent = ts;
  }

  function heartbeatFooter() {
    const icon = document.getElementById("connIcon");
    if (!icon) return;
    // restart animation even if class already present
    icon.classList.remove("beat");
    // force reflow so animation restarts reliably
    void icon.offsetWidth;
    icon.classList.add("beat");
  }

  function SSEHandler(d){
    try{
      const ch  = (d.virtual_channel ?? d.vch ?? 0);
      const rep = (d.repeat_index   ?? d.repeat ?? 0);
      const pct = d.percent ?? 0;
      const overallPct = d.overall_percent ?? 0;
      let phase = d.phase || "IDLE";

      applyPhase(phase);

      updateChannelInfo(ch, phase);
      updateRepeatInfo(rep);
      updateCircularProgress("runCircle", "runPct", pct);
      updateCircularProgress("overallCircle", "overallPct", overallPct);
      
    } catch(err){ appendLog('SSE parse error: ' + err); }
  }

  document.addEventListener('DOMContentLoaded', ()=>{
    loadPreferences();
    applyPhase("IDLE");
    window.GaseraHub?.subscribe(SSEHandler);
  });
})();
</script>
